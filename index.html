<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Oval Track with Fan Effect Game</title>
  <style>
    body {
      margin: 0;
      background: #333;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      background: #556B2F; /* Simulates grass */
      display: block;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
// =====================
// Game Setup Variables
// =====================

// Get canvas and context
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Oval Track Settings (elliptical track center and radii)
// We'll define an outer ellipse and an inner ellipse to form the track.
const trackCenter = { x: canvas.width / 2, y: canvas.height / 2 };
const outerRadii = { x: 300, y: 200 }; // Outer ellipse radii
const innerRadii = { x: 180, y: 120 }; // Inner ellipse radii

// Car object settings
const car = {
  x: trackCenter.x,
  y: trackCenter.y - 150,  // Starting position near outer edge
  angle: Math.PI / 2,       // Facing downward
  speed: 0,
  maxSpeed: 5,
  accel: 0.2,
  decel: 0.1,
  friction: 0.05,
  turnSpeed: 0.04,
  width: 20,
  height: 10
};

// Wind (Fan) effect: added force that pushes the car from left to right
const windForce = 0.05;

// Key state tracking
const keys = {};

// ============
// Event Listeners
// ============

window.addEventListener('keydown', (e) => {
  keys[e.key] = true;
});

window.addEventListener('keyup', (e) => {
  keys[e.key] = false;
});

// ============
// Game Functions
// ============

// Update car physics based on key inputs, applying wind each frame
function updateCar() {
  // Accelerate (up arrow)
  if (keys["ArrowUp"]) {
    car.speed += car.accel;
    if (car.speed > car.maxSpeed) car.speed = car.maxSpeed;
  }
  // Brake/Reverse (down arrow)
  if (keys["ArrowDown"]) {
    car.speed -= car.accel;
    if (car.speed < -car.maxSpeed/2) car.speed = -car.maxSpeed/2;
  }
  // Turn left/right (turn is scaled by the current speed)
  if (keys["ArrowLeft"]) {
    car.angle -= car.turnSpeed * (car.speed / car.maxSpeed);
  }
  if (keys["ArrowRight"]) {
    car.angle += car.turnSpeed * (car.speed / car.maxSpeed);
  }
  
  // Update position using the car's angle and speed
  car.x += Math.cos(car.angle) * car.speed;
  car.y += Math.sin(car.angle) * car.speed;
  
  // Apply the wind force that pushes the car to the right (increases x)
  car.x += windForce;
  
  // Apply friction when not accelerating or braking
  if (!keys["ArrowUp"] && !keys["ArrowDown"]) {
    if (car.speed > 0) {
      car.speed -= car.friction;
      if (car.speed < 0) car.speed = 0;
    } else if (car.speed < 0) {
      car.speed += car.friction;
      if (car.speed > 0) car.speed = 0;
    }
  }
  
  // Collision: Check if the car is off the oval track.
  // Outer ellipse test:
  let dxOuter = car.x - trackCenter.x;
  let dyOuter = car.y - trackCenter.y;
  let normOuter = (dxOuter * dxOuter) / (outerRadii.x * outerRadii.x) +
                  (dyOuter * dyOuter) / (outerRadii.y * outerRadii.y);
  
  // Inner ellipse test:
  let dxInner = car.x - trackCenter.x;
  let dyInner = car.y - trackCenter.y;
  let normInner = (dxInner * dxInner) / (innerRadii.x * innerRadii.x) +
                  (dyInner * dyInner) / (innerRadii.y * innerRadii.y);
  
  // If car is outside the outer boundary or inside the inner boundary, simulate collision.
  if (normOuter > 1 || normInner < 1) {
    car.speed = 0;
  }
}

// Draw the oval track using outer and inner ellipses.
function drawTrack() {
  ctx.save();
  ctx.translate(trackCenter.x, trackCenter.y);

  // Draw the outer ellipse (the road)
  ctx.beginPath();
  ctx.ellipse(0, 0, outerRadii.x, outerRadii.y, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#888"; // Road color
  ctx.fill();
  
  // Draw the inner ellipse (grass inside the track)
  ctx.beginPath();
  ctx.ellipse(0, 0, innerRadii.x, innerRadii.y, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#556B2F"; // Grass same as background
  ctx.fill();

  ctx.restore();
}

// Draw the car as a rotated rectangle
function drawCar() {
  ctx.save();
  ctx.translate(car.x, car.y);
  ctx.rotate(car.angle);
  // Draw the car body
  ctx.fillStyle = "#f00"; // Red car
  ctx.fillRect(-car.width/2, -car.height/2, car.width, car.height);
  
  // Draw a front indicator for the car (a small rectangle)
  ctx.fillStyle = "#fff";
  ctx.fillRect(car.width/4, -car.height/4, car.width/4, car.height/2);
  ctx.restore();
}

// Main Game Loop
function gameLoop() {
  // Clear canvas and redraw background (grass)
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  updateCar();
  drawTrack();
  drawCar();
  
  requestAnimationFrame(gameLoop);
}

// Start the game loop
requestAnimationFrame(gameLoop);
</script>

</body>
</html>
