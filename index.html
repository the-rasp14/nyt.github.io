<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simplified Suzuka Circuit with Fan Effect</title>
  <style>
    body {
      margin: 0;
      background: #333;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      background: #556B2F; /* "Grass" background */
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="900" height="600"></canvas>

<script>
// ---------------------------------------------------
// Basic Setup
// ---------------------------------------------------
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// A rough “center” of our canvas — used for track positioning.
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;

// Car object
const car = {
  x: centerX - 200, // Start to the left side
  y: centerY,       // Center vertically
  angle: 0,
  speed: 0,
  maxSpeed: 5,
  accel: 0.2,
  decel: 0.1,
  friction: 0.05,
  turnSpeed: 0.04,
  width: 20,
  height: 10
};

// "Wind" or "fan" effect that continuously pushes the car rightward
const windForce = 0.05;

// A simple bounding radius to reset speed if car goes too far from center
// (This is a placeholder “collision” check for going too far off the main area.)
const boundingRadius = 400;

// Key state tracking
const keys = {};

// ---------------------------------------------------
// Approximate Suzuka Path Data
// ---------------------------------------------------
//
// This is a very simplified, approximate version of Suzuka's figure-8 shape,
// laid out using a sequence of path segments. These coordinates were hand-picked
// to provide a rough impression of Suzuka. Real measurements would be far more exact.
//
// We'll draw a thick stroke to represent the track.
//
// You can tweak these points or add more Bezier curves to refine the shape.
const suzukaPath = [
  // We'll begin near the top-right and work around in a rough “figure-8” style
  { x: 180, y: -180 },
  { x: 130, y: -160 },
  { x: 90,  y: -140 },
  // S-curves
  { x: 40,  y: -100 },
  { x: 20,  y: -70 },
  { x: 0,   y: -40 },
  { x: -30, y: 0 },
  { x: -50, y: 30 },
  // Degner & Hairpin area
  { x: -70, y: 60 },
  { x: -90, y: 80 },
  { x: -70, y: 100 },
  { x: -30, y: 120 },
  // Spoon curve region
  { x: 10,  y: 140 },
  { x: 60,  y: 140 },
  { x: 90,  y: 120 },
  // Overpass “figure-8” cross
  { x: 120, y: 90 },
  { x: 150, y: 70 },
  { x: 180, y: 40 },
  { x: 220, y: 10 },
  { x: 250, y: -10 },
  // Final chicane / approach to front straight
  { x: 270, y: -40 },
  { x: 220, y: -90 },
  { x: 200, y: -130 },
  { x: 180, y: -180 }
];

// Fan location
const fan = {
  x: 60,
  y: 60,
  radius: 30
};

// ---------------------------------------------------
// Event Listeners
// ---------------------------------------------------
window.addEventListener('keydown', (e) => {
  keys[e.key] = true;
});
window.addEventListener('keyup', (e) => {
  keys[e.key] = false;
});

// ---------------------------------------------------
// Drawing Helpers
// ---------------------------------------------------

// Draw a simple arrow for “wind lines”
function drawArrow(fromx, fromy, tox, toy) {
  const headlen = 10; // length of the arrow head
  const dx = tox - fromx;
  const dy = toy - fromy;
  const angle = Math.atan2(dy, dx);
  
  ctx.beginPath();
  ctx.moveTo(fromx, fromy);
  ctx.lineTo(tox, toy);
  // left arrow head
  ctx.lineTo(
    tox - headlen * Math.cos(angle - Math.PI / 6),
    toy - headlen * Math.sin(angle - Math.PI / 6)
  );
  ctx.moveTo(tox, toy);
  // right arrow head
  ctx.lineTo(
    tox - headlen * Math.cos(angle + Math.PI / 6),
    toy - headlen * Math.sin(angle + Math.PI / 6)
  );
  ctx.strokeStyle = "#00f";
  ctx.lineWidth = 2;
  ctx.stroke();
}

// Draw the fan
function drawFan() {
  // Draw fan base (circle)
  ctx.save();
  ctx.translate(fan.x, fan.y);
  ctx.beginPath();
  ctx.arc(0, 0, fan.radius, 0, Math.PI * 2);
  ctx.fillStyle = "#bbb";
  ctx.fill();
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 2;
  ctx.stroke();

  // Fan blades (simple cross lines)
  ctx.strokeStyle = "#666";
  ctx.lineWidth = 4;
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(fan.radius - 5, 0);
    ctx.stroke();
    ctx.rotate(Math.PI / 2);
  }
  ctx.restore();

  // Wind arrows going from left to right
  for (let i = 0; i < 5; i++) {
    let startX = fan.x + fan.radius + 10 + i * 40;
    let startY = fan.y;
    let endX = startX + 30;
    let endY = startY;
    drawArrow(startX, startY, endX, endY);
  }
}

// Draw a simplified Suzuka circuit
function drawSuzukaTrack() {
  ctx.save();
  ctx.translate(centerX, centerY);
  
  ctx.beginPath();
  // Move to first point
  ctx.moveTo(suzukaPath[0].x, suzukaPath[0].y);
  
  // Connect the rest with lines
  for (let i = 1; i < suzukaPath.length; i++) {
    ctx.lineTo(suzukaPath[i].x, suzukaPath[i].y);
  }
  
  // A thick stroke to represent the track
  ctx.strokeStyle = "#888"; 
  ctx.lineWidth = 20;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";
  ctx.stroke();
  
  ctx.restore();
}

// Draw the car (simple rectangle)
function drawCar() {
  ctx.save();
  ctx.translate(car.x, car.y);
  ctx.rotate(car.angle);
  
  // Main body
  ctx.fillStyle = "#f00"; // Red
  ctx.fillRect(-car.width / 2, -car.height / 2, car.width, car.height);
  
  // Front indicator
  ctx.fillStyle = "#fff";
  ctx.fillRect(car.width / 4, -car.height / 4, car.width / 4, car.height / 2);
  
  ctx.restore();
}

// ---------------------------------------------------
// Game Logic
// ---------------------------------------------------
function updateCar() {
  // Accelerate (up arrow)
  if (keys["ArrowUp"]) {
    car.speed += car.accel;
    if (car.speed > car.maxSpeed) {
      car.speed = car.maxSpeed;
    }
  }
  // Brake / reverse (down arrow)
  if (keys["ArrowDown"]) {
    car.speed -= car.accel;
    if (car.speed < -car.maxSpeed / 2) {
      car.speed = -car.maxSpeed / 2;
    }
  }
  // Turn left / right
  if (keys["ArrowLeft"]) {
    car.angle -= car.turnSpeed * (car.speed / car.maxSpeed);
  }
  if (keys["ArrowRight"]) {
    car.angle += car.turnSpeed * (car.speed / car.maxSpeed);
  }

  // Update car position based on speed and angle
  car.x += Math.cos(car.angle) * car.speed;
  car.y += Math.sin(car.angle) * car.speed;
  
  // Apply fan / wind effect pushing the car to the right
  car.x += windForce;
  
  // Friction if no key is pressed for forward/back
  if (!keys["ArrowUp"] && !keys["ArrowDown"]) {
    if (car.speed > 0) {
      car.speed -= car.friction;
      if (car.speed < 0) car.speed = 0;
    } else if (car.speed < 0) {
      car.speed += car.friction;
      if (car.speed > 0) car.speed = 0;
    }
  }

  // Simple bounding check: if car is too far from center, reset speed
  const dx = car.x - centerX;
  const dy = car.y - centerY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist > boundingRadius) {
    car.speed = 0;
  }
}

// ---------------------------------------------------
// Main Game Loop
// ---------------------------------------------------
function gameLoop() {
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Fill background (grass)
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw fan (with wind arrows)
  drawFan();

  // Draw the Suzuka circuit
  drawSuzukaTrack();

  // Update car logic, then draw car
  updateCar();
  drawCar();
  
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
